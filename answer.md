# Answer These Questions Here, you can add additional pages to answer questions, just link to them so that I can view these questions and see your answer or the link(s) to your answer.

## FastAPI and Pydantic

1. **What role does Pydantic play in FastAPI, and how does it enhance data validation and settings management?**
   - Provide examples from the project where Pydantic is used.
   Pydantic handles request validation and schema definition in FastAPI. It enhances data validation and settings management by helping ensure that types supplied as arguments are valid.
   Pydantic is used in the schema, service, and config files often as a validator. For example, event_schema.py uses validator to ensure the title is not empty and end datetime is after start datetime.

2. **Outline the complete process of handling a user login request in your FastAPI application. Provide a step-by-step explanation with code examples from the project.**
The API compares the username and password with its records and, if a match is found, responds with a JSON Web Token (JWT) that is used for communications.
First, the user enters a username and password to log in. Next, this is verified as decribed above with the records given to the API. If a match is found, then a JWT is used to secure data within a session. All information is then encrypted/decrypted with this token. An example of the login process can be found in the async login method in the user_routes.py file.

3. **Explain the service repository pattern and how it is applied in your project. Provide an example of how routes are managed and linked to services.**
A service repository pattern is a relatively simple concept with the goal of separating "business" logic from data access logic. Instead of having users have control over the specific queries, a repository handles all the common logic related to a specific class. The service layer can query multiple repository classes to provided all the necessary query logic that a legitimate user might need. For example, in the event_service.py and user_service.py, there are specific parameters that can be used to perform queries but users themselves are not able to input their own custom queries beyond the allowed parameters. Routes are handled using an APIRouter that has dynamic get requests to get information. For example, @router.get("/events/{event_id}", response_model=EventResponse, name="get_event", tags=["Event Management Requires (Admin or Manager Roles)"]).

## Database Management with Alembic and SQLAlchemy

4. **How does Alembic manage database migrations, and why is this important for maintaining database schemas?**
   - Illustrate with an example of a migration script from the project.
   Alembic creates a baseline environment from which it can generate the changes needed to be made to get to a desired environment. These are called migration scripts. Then, you can run these scripts to migrate. You are also provided with rollback scripts to go back to a previous version. This is important because it allows for users to run tests without production environments without actually affecting the production server.

   One example of a migration script is the following for an initial migration:
"""initial migration

Revision ID: 6b62f34b7189
Revises: 
Create Date: 2024-04-26 20:38:55.377746

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '6b62f34b7189'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('users',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('nickname', sa.String(length=50), nullable=False),
    sa.Column('email', sa.String(length=255), nullable=False),
    sa.Column('first_name', sa.String(length=100), nullable=True),
    sa.Column('last_name', sa.String(length=100), nullable=True),
    sa.Column('bio', sa.String(length=500), nullable=True),
    sa.Column('profile_picture_url', sa.String(length=255), nullable=True),
    sa.Column('linkedin_profile_url', sa.String(length=255), nullable=True),
    sa.Column('github_profile_url', sa.String(length=255), nullable=True),
    sa.Column('role', sa.Enum('ANONYMOUS', 'AUTHENTICATED', 'MANAGER', 'ADMIN', name='UserRole', create_constraint=True), nullable=False),
    sa.Column('is_professional', sa.Boolean(), nullable=True),
    sa.Column('professional_status_updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.Column('last_login_at', sa.DateTime(timezone=True), nullable=True),
    sa.Column('failed_login_attempts', sa.Integer(), nullable=True),
    sa.Column('is_locked', sa.Boolean(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('verification_token', sa.String(), nullable=True),
    sa.Column('email_verified', sa.Boolean(), nullable=False),
    sa.Column('hashed_password', sa.String(length=255), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_users_email'), 'users', ['email'], unique=True)
    op.create_index(op.f('ix_users_nickname'), 'users', ['nickname'], unique=True)
    op.create_table('events',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('title', sa.String(length=255), nullable=False),
    sa.Column('description', sa.String(length=1000), nullable=True),
    sa.Column('start_datetime', sa.DateTime(timezone=True), nullable=False),
    sa.Column('end_datetime', sa.DateTime(timezone=True), nullable=False),
    sa.Column('published', sa.Boolean(), nullable=False),
    sa.Column('event_type', sa.Enum('COMPANY_TOUR', 'MOCK_INTERVIEW', 'GUEST_LECTURE', name='eventtype'), nullable=False),
    sa.Column('creator_id', sa.UUID(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['creator_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('events')
    op.drop_index(op.f('ix_users_nickname'), table_name='users')
    op.drop_index(op.f('ix_users_email'), table_name='users')
    op.drop_table('users')
    # ### end Alembic commands ###

## Pytest

5. **Why is Pytest critical for the development of the API?**
Pytest allows us to automate most, if not all of the tests to ensure there are no vulnerable blind spots while pushing changes. Otherwise, there would need to be an operator manually testing every way a user can use the program whenever a change is pushed. This not only saves time spent testing but also helps ensure that the tests are comprehensive.

## JWT and User Authentication

6. **Explain the functioning of JWT (JSON Web Tokens) in user authentication. How are JWTs generated, encoded, and used within the project?**
   - [Read this article and link to the code in the user management.](https://supertokens.com/blog/what-is-jwt)
   - Include a code snippet showing how JWTs are implemented in the project.
   JWTs are used for authentication and authorization of a user. JWTs are generated on the server side and digitally signed, then the client submits the JWT with every following request. Within projects, this ensures that a client is who they claim they are as the token cannot be edited without being considered invalid as it is digitally signed. For example, in our code, user_routes.py creates a JWT when the user logs in then that token is used with every request that requires authentication afterwards.

7. **Decode the following JWT and explain its contents:**
   - Token: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJqb2huLmRvZUBleGFtcGxlLmNvbSIsInJvbGUiOiJBRE1JTiIsInVzZXJfaWQiOiJjZGY4M2QzZi0zNzQ5LTRjZGQtOTRlYS1hNTVjZmMwNDhkMGYiLCJleHAiOjE3MTc2MTY4MjAuMjIwNzA5fQ.ANS8PgUiwPCmOvnZLYTCy_5WzLyhCDOx8aF4xu-Kaz8`
   - Use [jwt.io](https://jwt.io/) to decode and explain the contents.

The header includes the hashing algorithm and the token type, which are HS256 and JWT respectively. The payload has four keys: sub, role, user_id, and exp with values john.doe@example.com, ADMIN, cdf83d3f-3749-4cdd-94ea-a55cfc048d0f, and 1717616820.220709. The sub is who the token refers to, the role is a method of authorization, user_id is a unique id to identify a user, and the exp is the expiration datetime of the token. 

8. **Describe the user registration logic in your project. Provide a pseudo-code workflow from the registration request to storing the user in the database.**
When a user registers, they call the register async function in user_routes.py. This then calls the register_user function which eventually checks if the email is already registered, if not, then stores the email and hash of the password and generates a nickname. A token is then created and a verification email sent, and the user information is returned using UserResponse.model_construct.

9. **Detail the steps involved in the user email verification process. Provide a pseudo-code workflow from sending a verification email to activating the user's account.**
After a user register's their account, a verification email is sent. Upon verifying, the UserService.verify_email_with_token method is called which checks the token. If the token is valid, then the user is verified and the user can continue their session.

## Security Practices

10. **How do you ensure the security of user passwords in your project? Discuss the hashing algorithm used and any additional security measures implemented.**
The data sent by the user is encrypted, then on the server side it is decrypted to get the plain text password. This password is then salted, hashed, and stored for future verification. The Blowfish encryption algorithm is used for hashing.

11. **Explain the difference between hashing and encoding. Provide examples from your project where each is used:**
    - **Hashing:** Hashing converts the values of an input to a constant space value. In our code, it is used like this, where salt is a generated random value: hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)
    - **Encoding:** Encoding simply converts data from one form to another, for example, ASCII to UTF-8 which is also done in the same line of code above, specifically here: password.encode('utf-8').
    Both examples are from security.py

## Project Management with Docker and CI/CD

12. **Discuss the advantages of using Docker Compose for running your project. How does it help in maintaining a consistent development and deployment environment?**
Docker Compose allows a user to run several containers with different running services. This allows for upgrades to be made to one without having to change an entire container, and subsequently, rollbacks are easier to perform. It helps maintain consistent development and deployment environments by allowing different containers to continue their operation and seamlessly switch out upgraded containers for their older counterparts. 

13. **Describe the role of GitHub Actions in your project's CI/CD pipeline. How do you automate testing and deployment using GitHub Actions?**
GitHub actions allows developers to test or perform specific actions within their repository following every pull request (or sooner if desired). This can be automated using GitHub workflows to install dependencies or run scripts each time a event occurs.

## API Design and Implementation

14. **What are REST APIs, and how do they function in your project? Provide an example of a REST endpoint from your user management system.**
REST APIs are interfaces that follow the principles of the Representational State Transfer (REST) architectural style, enabling flexible and lightweight integration of applications. They are stateless, meaning each request contains all necessary information for processing. An example of a REST endpoint from our user management system is here:
@router.put(
        "/myaccount/", 
        response_model=UserResponse, 
        name="update_myaccount", 
        tags=["My Account"]
        )
async def update_myaccount(
    user_update: UserUpdate, 
    request: Request, 
    db: AsyncSession = Depends(get_db), 
    current_user: dict = Depends(get_current_user)):
    
    try:
        user_data = user_update.model_dump(exclude_unset=True)
        user_id = current_user["user_id"]
        updated_user = await UserService.update(db, user_id, user_data)
        return UserResponse.model_construct(
            id=updated_user.id,
            bio=updated_user.bio,
            first_name=updated_user.first_name,
            last_name=updated_user.last_name,
            nickname=updated_user.nickname,
            email=updated_user.email,
            role=updated_user.role,
            last_login_at=updated_user.last_login_at,
            profile_picture_url=updated_user.profile_picture_url,
            github_profile_url=updated_user.github_profile_url,
            linkedin_profile_url=updated_user.linkedin_profile_url,
            created_at=updated_user.created_at,
            updated_at=updated_user.updated_at,
            links=create_user_links(updated_user.id, request)
        )
    except UserNotFoundException as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected error occurred.")

15. **What is HATEOAS (Hypermedia as the Engine of Application State)? Provide an example of its implementation in your project's API responses, along with a screenshot.**
HATEOAS is a principle of REST architecture that allows clients to interact with a server application dynamically through hypermedia. The server provides possible actions in its responses, enabling the client to navigate through application states by interacting with these hypermedia links. Here is an example:
@router.get("/events/{event_id}", response_model=EventResponse, name="get_event", tags=["Event Management Requires (Admin or Manager Roles)"])
async def get_event(event_id: UUID, request: Request, db: AsyncSession = Depends(get_db), token: str = Depends(oauth2_scheme), current_user: dict = Depends(require_role(["ADMIN", "MANAGER"]))):
    event = await EventService.get_by_id(db, event_id)
    if not event:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Event not found")

    return EventResponse.model_construct(
        id=event.id,
        title=event.title,
        description=event.description,
        start_datetime=event.start_datetime,
        end_datetime=event.end_datetime,
        published=event.published,
        event_type=event.event_type,
        creator_id=event.creator_id,
        created_at=event.created_at,
        updated_at=event.updated_at,
        links=create_event_links(event.id, request)
    )

## Role-Based Access Control (RBAC)

16. **What is Role-Based Access Control (RBAC) and how is it implemented in your project?**
Role-Based Access Control is when permissions are assigned to a role which can be inherited by users rather than assigning permissions directly to accounts. It is implemented in this project through JWTs, some using the ADMIN role.

17. **Explain the different user roles defined in your project (ANONYMOUS, AUTHENTICATED, MANAGER, ADMIN) and their permissions.**
ANONYMOUS: Users not logged in, can access public pages.
AUTHENTICATED: Logged-in users, can manage their own data.
MANAGER: Can manage users or specific resources.
ADMIN: System administrators, have full access.

18. **Provide a code example showing how RBAC is enforced in one of your FastAPI endpoints.**
@router.get("/events/{event_id}", response_model=EventResponse, name="get_event", tags=["Event Management Requires (Admin or Manager Roles)"])
async def get_event(event_id: UUID, request: Request, db: AsyncSession = Depends(get_db), token: str = Depends(oauth2_scheme), current_user: dict = Depends(require_role(["ADMIN", "MANAGER"]))):
    event = await EventService.get_by_id(db, event_id)
    if not event:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Event not found")

    return EventResponse.model_construct(
        id=event.id,
        title=event.title,
        description=event.description,
        start_datetime=event.start_datetime,
        end_datetime=event.end_datetime,
        published=event.published,
        event_type=event.event_type,
        creator_id=event.creator_id,
        created_at=event.created_at,
        updated_at=event.updated_at,
        links=create_event_links(event.id, request)
    )


## Route Parameters and Pydantic Schemas

19. **Explain how route parameters are used in FastAPI. Provide an example of a route that takes a parameter and demonstrate how it is used within the endpoint.**
In FastAPI, route parameters are dynamic parts of the URL used to capture values. They are defined in the path like /items/{item_id} and passed to your function as arguments. You can declare their type (like int or str), and FastAPI will automatically handle data conversion, validation, and generate API documentation.
An example in the code is the following, which is used to get an event with a specific ID:
@router.get("/events/{event_id}", response_model=EventResponse, name="get_event", tags=["Event Management Requires (Admin or Manager Roles)"])
async def get_event(event_id: UUID, request: Request, db: AsyncSession = Depends(get_db), token: str = Depends(oauth2_scheme), current_user: dict = Depends(require_role(["ADMIN", "MANAGER"]))):
    event = await EventService.get_by_id(db, event_id)
    if not event:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Event not found")

    return EventResponse.model_construct(
        id=event.id,
        title=event.title,
        description=event.description,
        start_datetime=event.start_datetime,
        end_datetime=event.end_datetime,
        published=event.published,
        event_type=event.event_type,
        creator_id=event.creator_id,
        created_at=event.created_at,
        updated_at=event.updated_at,
        links=create_event_links(event.id, request)
    )

20. **How does FastAPI use Pydantic schemas to generate Swagger documentation? Provide an example from your project where a Pydantic schema is used and show the corresponding Swagger documentation.**
FastAPI uses Pydantic models to define request and response structures, which are then used to generate JSON Schema. This schema is used by FastAPI to automatically create interactive Swagger documentation for your API, providing details about endpoints, models, and parameters.
class UserRole(Enum):
    """Enumeration of user roles within the application, stored as ENUM in the database."""
    ANONYMOUS = "ANONYMOUS"
    AUTHENTICATED = "AUTHENTICATED"
    MANAGER = "MANAGER"
    ADMIN = "ADMIN"


These questions ensure a comprehensive assessment of the students' understanding of the topics related to your project setup, focusing on practical implementations and theoretical concepts.